#summary How to compile and use the IR Toolkit.
#labels Featured,Phase-Deploy

= Introduction =

This document will explain the system requirements necessary for the IR Toolkit, as well as how to compile it, and it's various usage modes.


= System Requirements =

The IR Toolkit has been developed with and tested on recent Linux distributions; however, it should run on POSIX compliant operating systems (but perhaps with some tweaks).

= Compiling =

The IR Toolkit uses standard C++ as much as possible. It's been compiled with GCC 4.3 (recent version should work OK). It's possible there is some GCC specific code (but very little). It comes with a Makefile, so as long as the following libraries are installed in their default locations, it should compile without changes.

*Dependent Libraries:*
 * zlib
 * POSIX Threads
 * POSIX Asynchronous I/O (AIO)

The Threads and AIO libraries should come with any POSIX compliant OS.

= Code Style =

If you want to hack the IR Toolkit, you'll find that the code style closely follows that of the [http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml Google C++ Style Guide].

= Configuration =

The IR Toolkit comes with a sample configuration file, which is called 'irtk.conf'. There are many powerful options, which are all described in the configuration file. Some of the things that can be done through the configuration file:
 * Tune memory usage.
 * Change index coding policies for docIDs, frequencies, positions, and block headers.
 * Set whether positions and contexts are to be indexed.
 * There are separate coding policies and options for data to be included in the index for both the initial indexing step and the merging step; thus, an index could be generated with one set of codings and positions, and then re-merged to be without positions and a different set of coding policies.

= Command Line Options =


= Index Slices =

An index slice is a complete and queryable index, consisting of the following files:
 * index.idx[.x.y]
 * index.lex[.x.y]
 * index.dmap[.x.y]
 * index.meta[.x.y]

The part in between [...] is optional. A fully merged index will not have the .x.y extension.
The x and y are simply numbers which are assigned by the index merger to distinguish indices. The initial indices, resulting from the indexing step have x equal to 0, and y is just an incrementing index count. Each pass that the merger makes over the index collection will result in an incrementing x, and y is still just an index count within that pass.

= Indexing =


= Merging =


= Querying =