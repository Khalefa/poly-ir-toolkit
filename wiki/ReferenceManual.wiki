#summary How to compile and use the Poly IR Toolkit.
#labels Featured

= Introduction =
This document will explain the system requirements necessary for the Poly IR Toolkit (referred to as PolyIRTK from here on), as well as how to compile it, and it's various usage modes.

= System Requirements =
PolyIRTK has been developed with and tested on recent Linux distributions; however, it should run on POSIX compliant operating systems (but perhaps with some tweaks).

= Compiling =
PolyIRTK uses standard C++ as much as possible. It's been compiled with GCC 4.x (recent versions should work OK). It's possible there is some GCC specific code (but not much). It comes with a Makefile, so as long as the following libraries are installed in their default locations, it should compile without changes.

*Dependent Libraries:*
 * zlib
 * POSIX Threads
 * POSIX Asynchronous I/O (AIO)

The Threads and AIO libraries should come with any POSIX compliant OS.

= Code Style =
If you would like to hack on PolyIRTK, you'll find that the code style closely follows that of the [http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml Google C++ Style Guide]. I felt it was very practical and easy to follow.
The main deviation is in the maximum horizontal line size; instead of 80 characters, PolyIRTK uses 160 characters, which I feel takes better advantage of high resolution widescreen monitors.

= Configuration =
PolyIRTK comes with a sample configuration file, 'irtk.conf'. There are many powerful options, which are described in the sample configuration file. Some of the things that can be done through the configuration file:
 * Tune memory usage for the various modes.
 * Define the index coding policies for docIDs, frequencies, positions, and block headers. There are separate coding policies for the indexing and merging steps, allowing you to generate an index with one set of coding policies, and then re-merge with a different set of coding policies.
 * Control whether the index will be indexed/merged with positions (word level index).
 * Control whether the index will remain cached on disk, or loaded fully into main memory.

= Command Line Usage =
PolyIRTK tries to play nice with other UNIX tools; many of the options allow input to come from stdin so that they could be used with pipes and I/O redirection.

== Indexing ==
Example usage:

*`./irtk --index < input`*

The indexer reads the paths to the files it should index from standard in; the above command redirects the standard input to come from a file called input.
The input file is a plain text file that should contain the absolute paths (or relative to the current directory) to the files you need to index, one per line.
PolyIRTK can index either TREC (i.e. Gov2 dataset) or WARC (i.e. ClueWeb dataset) formatted files; however, they must be gzipped. The type of input file is specified in the configuration file.

== Merging ==
Example usage:

*`./irtk --merge`*

This command will merge all the index slices from the initial indexing step (with extension 0.y) into one index, consisting of the files index.idx, index.lex, index.dmap, and index.meta. Depending on the configuration file, intermediate slices may also be left (otherwise, they will be deleted).

*`./irtk --merge-input`*

In this command, the merger will read from stdin those files you want to merge followed by the new index slice name.

=== Additional Options ===
*`--merge-degree=[value]`*

Specify the merge degree to use (default is 64)

== Querying ==
*To query:* `irtk --query [IndexName]`

Queries the index slice. If the !IndexName are left out, the default is to use index slice with the files index.idx, index.lex, index.dmap, index.meta.

_additional options:_ `--query-mode=[value]`
Set the querying mode. Value is one of 'interactive', 'interactive-single', or 'batch'.

== Debug and Performance ==
*To cat:* `irtk --cat [IndexName]`

*To diff:* `irtk --diff [IndexName1] [IndexName2]`

*To run compression tests:* `irtk --test-compression`

*To test a particular coder:* `irtk --test-coder [rice, turbo-rice, pfor, s9, s16, vbyte, null]`


== Loop over index data ==


== Remapping ==

First, generate the remapping file. Currently, PolyIRTK only support reordering docIDs by their URLs.

`irtk --generate-url-sorted-doc-mapping=url_sorted_doc_id_mapping < input`

Note that it's important that the input files are the same ones, and appear in the same order, as those used to generate the index that's going to be remapped. This is because the docIDs are assigned sequentially during the indexing process, and me must remap based on these same sequentially assigned docIDs.
The output of the above command will produce a file named 'url_sorted_doc_id_mapping'.

This file can be used as an input to the actual docID reordering procedure.

`irtk --remap=url_sorted_doc_id_mapping`

The output of the remapping procedure will be a new index with the prefix 'index_remapped'.

To query, you must specify the name of the remapped index to use, like so:

`irtk --query index_remapped.idx index_remapped.lex index.dmap index_remapped.meta`

During querying, the document map will load the mapping file, in order to properly be able to translate the document lengths and URLs.
Note that for querying, currently, the mapping file must be named 'url_sorted_doc_id_mapping'.

== Layering ==

= Index Slices =

An index slice is a complete and queryable index, consisting of the following files:
 * `[`index_name`]`.idx`[`.x.y`]`
 * `[`index_name`]`.lex`[`.x.y`]`
 * index.dmap_basic
 * index.dmap_extended
 * `[`index_name`]`.meta`[`.x.y`]`
 * `[`index_name`]`.ext`[`.x.y`]`

The part in between `[`...`]` is optional. A fully merged index will not have the .x.y extension. The x and y are simply numbers which are assigned by the index merger to distinguish indices. The initial indices, resulting from the indexing step have x equal to 0, and y is just an incrementing index count. Each pass that the merger makes over the index collection will result in an incrementing x, and y is still just an index count within that pass.

The .idx extension is for inverted index files.
The .lex extension is for lexicon files.
The .dmap_basic and .dmap_extended extensions are for document map files. A .dmap_basic file consists of document lengths and offsets into the .dmap_extended files. The .dmap_extended file consists of document URLs and document TREC numbers.
The .meta extension indicates that the file is a meta file.

Index slices can be merged into larger index slices, as is described in the Merging section.
